<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style>
			* {
				border: 0;
				padding: 0;
				margin: 0;
			}

			html,
			body {
				width: 100%;
				height: 100%;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
	</body>
	<script>
		const canvas = document.getElementById("canvas");
		const ctx = canvas.getContext("2d");
		const width = canvas.width = window.innerWidth;
		const height = canvas.height = window.innerHeight;

		function random(min, max) {
			return Math.floor(Math.random() * (max - min)) + min;
		}

		function randomColor() {
			return "rgb(" + random(0, 255) + "," + random(0, 255) + "," + random(0, 255) + ")";
		}

		function Shape(x, y, velX, velY,exists) {
			this.x = x;
			this.y = y;
			this.velX = velX;
			this.velY = velY;
			this.exists=exists;
		}
		
		function Ball(x,y,velX,VelY,color,size,exists)
		{
			Shape.call(this,x,y,velX,VelY,true);
			this.color=color;
			this.size=size;
		}
		function EvilCircle(x,y,velX,VelY)
		{
			Shape.call(this,x,y,20,20,true);
			this.color="white";
			this.size=10;
		}
		
		//给小球原型添加方法
		Ball.prototype.draw = function() {
			ctx.beginPath(); //开始绘画
			ctx.fillStyle = this.color; //设置颜色
			ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //圆弧
			ctx.fill(); //结束绘画并填充颜色
		}
		
		EvilCircle.prototype.draw = function() {
			ctx.beginPath(); //开始绘画
			ctx.lineWidth=3;
			ctx.strokeStyle = this.color; //设置颜色
			ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //圆弧
			ctx.stroke(); //结束绘画并填充颜色
		}

		Ball.prototype.update = function() {
			if ((this.x + this.size) >= width) {
				this.velX = -(this.velX);
			}

			if ((this.x - this.size) <= 0) {
				this.velX = -(this.velX);
			}

			if ((this.y + this.size) >= height) {
				this.velY = -(this.velY);
			}

			if ((this.y - this.size) <= 0) {
				this.velY = -(this.velY);
			}
			this.x += this.velX;
			this.y += this.velY;
		}
		
		EvilCircle.prototype.checkBounds = function() {
			if ((this.x + this.size) >= width) {
				this.x = width-this.size;
			}
		
			if ((this.x - this.size) <= 0) {
				this.x = this.size;
			}
		
			if ((this.y + this.size) >= height) {
				this.y = height-this.size;
			}
		
			if ((this.y - this.size) <= 0) {
				this.y = this.size;
			}
		}
		
		EvilCircle.prototype.setControls=function()
		{
			window.onkeydown=e=>
			{
				if(e.key==="a")
				{
					this.x -= this.velX;
				}
				if(e.key==="d")
				{
					this.x += this.velX;
				}
				if(e.key==="w")
				{
					this.y -= this.velY;
				}
				if(e.key==="s")
				{
					this.y += this.velY;
				}
			}
		}
		
		EvilCircle.prototype.collisionDetect=function()
		{
			for (let j = 0; j < balls.length; j = j + 1) {
				const dx = this.x - balls[j].x;
				const dy = this.y - balls[j].y;
				const distance = Math.sqrt(dx * dx + dy * dy);
							
				if (distance < this.size + balls[j].size) {
					balls[j].exists=false;
				}
			}
		}
		//碰撞检测
		Ball.prototype.collisonDetect = function() {
			for (let j = 0; j < balls.length; j = j + 1) {
				if (this !== balls[j]) {
					const dx = this.x - balls[j].x;
					const dy = this.y - balls[j].y;
					const distance = Math.sqrt(dx * dx + dy * dy);

					if (distance < this.size + balls[j].size) {
						balls[j].color = randomColor();
						this.color = randomColor();
					}
				}
			}
		}

		let balls = [];
		let evil=new EvilCircle(100,100,5,5,);
		evil.setControls();

		while (balls.length < 25) {
			let size = random(10,25);
			let ball = new Ball(random(size, width - size), random(size, height - size), random(-6, 6), random(-10, 10),
				randomColor(), size);
			balls.push(ball);
		}

		function loop() {
			ctx.fillStyle = "rgba(0,0,0,0.25)";
			ctx.fillRect(0, 0, width, height);

			for (let i = 0; i < balls.length; i = i + 1) {
				if(balls[i].exists)
				{
					balls[i].draw();
					balls[i].update();
					balls[i].collisonDetect();
				}
			}
			evil.draw();
			evil.checkBounds();
			evil.collisionDetect();

			requestAnimationFrame(loop);
		}

		loop();
	</script>
</html>
